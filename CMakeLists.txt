
# OpenCMISS-Cmgui Application
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


cmake_minimum_required( VERSION 3.10 )

project(CmguiApplication)

set(CMAKE_CXX_STANDARD 11)
# Check bare minimum configuration
set(CMGUI_CMAKE_MODULE_PATH "${CMGUI_CMAKE_MODULE_PATH}" CACHE STRING "Location of OpenCMISS CMake modules.")
if (NOT EXISTS "${CMGUI_CMAKE_MODULE_PATH}/OpenCMISS/OCMiscFunctions.cmake")
    message(FATAL_ERROR "'${CMGUI_CMAKE_MODULE_PATH}/OpenCMISS/OCMiscFunctions.cmake' does not exists.  The OpenCMISS CMake modules may not be installed/available.")
endif ()

list(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
list(APPEND CMAKE_MODULE_PATH "${CMGUI_CMAKE_MODULE_PATH}/FindModuleWrappers")
list(APPEND CMAKE_MODULE_PATH "${CMGUI_CMAKE_MODULE_PATH}")
list(APPEND CMAKE_MODULE_PATH "${CMGUI_CMAKE_MODULE_PATH}/OpenCMISS")

INCLUDE( FunctionDefinitions )

SET( CMGUI_RELEASE FALSE )
SET( CMGUI_MAJOR_VERSION "3" )
SET( CMGUI_MINOR_VERSION "2" )
SET( CMGUI_PATCH_VERSION "0" )
SET( CMGUI_VERSION ${CMGUI_MAJOR_VERSION}.${CMGUI_MINOR_VERSION}.${CMGUI_PATCH_VERSION} )

find_package(Git)
if (GIT_FOUND)
    git_get_revision(CMGUI_REVISION_LONG)
    string(SUBSTRING ${CMGUI_REVISION_LONG} 0 6 CMGUI_REVISION)
    git_is_dirty(_IS_DIRTY)
    if (_IS_DIRTY)
        set(CMGUI_REVISION "${CMGUI_REVISION}*")
    endif ()
endif()

IF( NOT CMGUI_RELEASE )
	SET( CMGUI_DEVELOPER_VERSION ".r${CMGUI_REVISION}" )
ENDIF()

MACRO( CACHE_VAR_WITH_DEFAULT OPTION_NAME OPTION_DEFAULT OPTION_TYPE OPTION_STRING )
	IF( NOT DEFINED ${OPTION_NAME} )
		SET( ${OPTION_NAME} ${OPTION_DEFAULT} )
	ENDIF( NOT DEFINED ${OPTION_NAME} )

	SET( ${OPTION_NAME} "${OPTION_DEFAULT}" CACHE ${OPTION_TYPE} "${OPTION_STRING}" )
ENDMACRO( CACHE_VAR_WITH_DEFAULT OPTION_NAME OPTION_DEFAULT OPTION_TYPE OPTION_STRING )

CACHE_VAR_WITH_DEFAULT( CMGUI_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}"
	PATH "Where do you want your Cmgui libraries installed?" )
SET( CMAKE_INSTALL_PREFIX ${CMGUI_INSTALL_PREFIX} CACHE INTERNAL "Internalise CMAKE_INSTALL_PREFIX, manipulate via CMGUI_INSTALL_PREFIX" FORCE )
CACHE_VAR_WITH_DEFAULT( CMGUI_BUILD_TYPE "Release"
	STRING "What configuration do you want to build: Debug, Release, MinSizeRel, RelWithDebugInfo" )
SET( CMAKE_BUILD_TYPE ${CMGUI_BUILD_TYPE} CACHE INTERNAL "Internalise CMAKE_BUILD_TYPE, manipulate via CMGUI_BUILD_TYPE" FORCE )

SET( WXWIDGETS_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}" CACHE PATH "Location of the Cmgui's wxWidgets libraries." )

find_package(cmiss_perl_interpreter QUIET)

OPTION( USE_PERL_INTERPRETER "Do you want to use the perl interpreter?" ${CMISS_PERL_INTERPRETER_FOUND} )
OPTION( WX_USER_INTERFACE "use wx for interface." )
OPTION( GTK_USER_INTERFACE "use gtk for interface." )
OPTION( WIN32_USER_INTERFACE "use win32 for interface." )

# Find our friendly Zinc CMake config file.
# We can only use the static version of the library for the Cmgui application
SET( ZINC_USE_STATIC TRUE )
SET( REQUIRE_INTERNAL_ZINC_INCLUDE_DIR TRUE )
FIND_PACKAGE( Zinc REQUIRED )

IF( WX_USER_INTERFACE )
#	SET( CMAKE_PREFIX_PATH ${WXWIDGETS_INSTALL_PREFIX} )
#	find_package(wxWidgets REQUIRED CONFIG PATH_SUFFIXES share/wxwidgets)
	FIND_PACKAGE( wxWidgets REQUIRED COMPONENTS xrc adv html gl xml core base )
	SET( CAN_USE_USER_INTERFACE ${wxWidgets_FOUND} )
ENDIF( WX_USER_INTERFACE )
#IF( GTK_USER_INTERFACE )
#	FIND_PACKAGE( GTK2 REQUIRED gtk)
#	FIND_PACKAGE( GTKGLext REQUIRED )
#	SET( CAN_USE_USER_INTERFACE ${GTK2_FOUND} )
#ENDIF( GTK_USER_INTERFACE )
#IF( WIN32_USER_INTERFACE AND WIN32 )
#	SET( CAN_USE_USER_INTERFACE TRUE )
#ENDIF( WIN32_USER_INTERFACE AND WIN32 )


IF(WIN32)
        SET( WIN32_SYSTEM TRUE )
ENDIF()

IF( MSVC )
	SET( EXTRA_COMPILER_DEFINITIONS _CRT_SECURE_NO_WARNINGS )
ENDIF( MSVC )

# User interfaces
# wxwidgets - is a config file on win32 and not on configure enabled platforms
IF( WX_USER_INTERFACE )
	FUNCTION( WXWIDGETS_HDRS XRC_SRCS _OUTFILES )

			FOREACH( XRC_SRC ${XRC_SRCS} )
					STRING( REGEX MATCH "(.*)/([a-z_A-Z]*)\\.xrc$" DUMMY "${XRC_SRC}" )
					IF( NOT EXISTS ${PROJECT_BINARY_DIR}/${CMAKE_MATCH_1} )
							FILE( MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/${CMAKE_MATCH_1} )
					ENDIF( NOT EXISTS ${PROJECT_BINARY_DIR}/${CMAKE_MATCH_1} )
					SET( XRC_FCN ${CMAKE_MATCH_2} )
					WXWIDGETS_ADD_RESOURCES( XRC_OUTPUT ${XRC_SRC} OPTIONS --cpp-code
							--function=wxXmlInit_${XRC_FCN} --output=${PROJECT_BINARY_DIR}/${XRC_SRC}h )
			ENDFOREACH( XRC_SRC ${XRC_SRCS} )

			SET( ${_OUTFILES} ${XRC_OUTPUT} PARENT_SCOPE )
	ENDFUNCTION( WXWIDGETS_HDRS _OUTFILES )

	IF( WIN32 AND NOT CYGWIN AND NOT MSYS )
		# Do nothing, have config file
	ELSE( WIN32 AND NOT CYGWIN AND NOT MSYS )
#		IF( UNIX OR MSYS )
#			IF( ${CMAKE_BUILD_TYPE} MATCHES "[Dd]ebug" )
#				SET( wxWidgets_USE_DEBUG TRUE )
#			ELSE( ${CMAKE_BUILD_TYPE} MATCHES "[Dd]ebug" )
#				SET( wxWidgets_USE_DEBUG FALSE )
#			ENDIF( ${CMAKE_BUILD_TYPE} MATCHES "[Dd]ebug" )
#			SET( wxWidgets_USE_UNICODE FALSE )
#			SET( wxWidgets_USE_UNIVERSAL FALSE )
#			SET( wxWidgets_USE_STATIC TRUE )
#			FIND_PACKAGE( wxWidgets COMPONENTS xrc adv html
#				gl xml core base )
#		ENDIF( UNIX OR MSYS )
	ENDIF( WIN32 AND NOT CYGWIN AND NOT MSYS )
	IF( wxWidgets_FOUND )
		SET( USE_WXWIDGETS TRUE )
		MARK_AS_ADVANCED( wxWidgets_DIR )
#		DBG_MSG( "C FLAGS: ${wxWidgets_CXX_FLAGS}" )
#		DBG_MSG( "LIBS: ${wxWidgets_LIBRARIES}" )
#		SET( WXWIDGETS_LIBRARIES ${wxWidgets_LIBRARIES} )
#		DBG_MSG( "DEFS: ${wxWidgets_DEFINITIONS}" )
#		DBG_MSG( "INC_DIRS: ${wxWidgets_INCLUDE_DIRS}" )
#		SET( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${wxWidgets_CXX_FLAGS}" )
#		SET( DEPENDENT_DEFINITIONS ${DEPENDENT_DEFINITIONS} ${wxWidgets_DEFINITIONS} )
#		SET( DEPENDENT_CONFIGS "${DEPENDENT_CONFIGS}\nSET( wxWidgets_wxrc_EXECUTABLE ${wxWidgets_wxrc_EXECUTABLE} )" )
#		IF( MSVC )
#			SET( EXTRA_COMPILER_DEFINITIONS ${EXTRA_COMPILER_DEFINITIONS} wxUSE_NO_MANIFEST=1 )
#			SET( DEPENDENT_DEFINITIONS ${DEPENDENT_DEFINITIONS} wxUSE_NO_MANIFEST=1 )
#		ENDIF( MSVC )
		INCLUDE( source/cmake/xrc_source_files.cmake )
#		DBG_MSG( "XRC SRCS: ${XRC_SRCS}" )
		WXWIDGETS_HDRS( "${XRC_SRCS}" wxWidgets_GENERATED_HDRS )
	ELSE( wxWidgets_FOUND )
		MESSAGE( FATAL_ERROR "wxWidgets was requested but not found." )
	ENDIF( wxWidgets_FOUND )
ENDIF( WX_USER_INTERFACE )

IF( GTK_USER_INTERFACE )
	IF( GTK2_FOUND )
		IF( NOT GTKGLEXT_FOUND )
			MESSAGE( FATAL_ERROR "gtkglext was requested but not found." )
		ENDIF( GTKGLEXT_FOUND )
	ELSE( GTK2_FOUND )
		MESSAGE( FATAL_ERROR "gtk2 was requested but not found." )
	ENDIF( GTK2_FOUND )
ENDIF( GTK_USER_INTERFACE )

INCLUDE(source/cmake/app_srcs.cmake)
INCLUDE(source/cmake/app_hdrs.cmake)

IF( APPLE )
	SET( OSX_ICON source/icon/cmiss_torso.icns )
	SET_SOURCE_FILES_PROPERTIES( ${OSX_ICON} PROPERTIES MACOSX_PACKAGE_LOCATION Resources )
ENDIF()

GET_CMGUI_SYSTEM_NAME( CMGUI_SYSTEM_NAME )
SET( CMGUI_VERSION_STRING "\"${CMGUI_VERSION}\"" )
SET( CMGUI_REVISION_STRING "\"${CMGUI_REVISION}\"" )
SET( CMGUI_BUILD_STRING "${CMGUI_SYSTEM_NAME}" )
IF( WX_USER_INTERFACE )
	SET( CMGUI_BUILD_STRING "${CMGUI_BUILD_STRING} wxWidgets")
ENDIF( )
IF( GTK_USER_INTERFACE )
	SET( CMGUI_BUILD_STRING "${CMGUI_BUILD_STRING} gtk")
ENDIF( )
IF( WIN32_USER_INTERFACE )
	SET( CMGUI_BUILD_STRING "${CMGUI_BUILD_STRING} win32")
ENDIF( )
IF( USE_PERL_INTERPRETER )
	SET( CMGUI_BUILD_STRING "${CMGUI_BUILD_STRING} perl")
ENDIF( )
SET( CMGUI_BUILD_STRING "\"${CMGUI_BUILD_STRING}\"" )
SET( CMGUI_CONFIGURE_HDR ${PROJECT_BINARY_DIR}/source/configure/cmgui_configure.h )
CONFIGURE_FILE( ${PROJECT_SOURCE_DIR}/source/configure/cmgui_configure.h.cmake ${CMGUI_CONFIGURE_HDR} )

# To get the internal headers we derive a header search path from the build header source path.
# Obviously this will not work if you configure with Zinc's install tree.
#LIST( GET ZINC_INCLUDE_DIRS 0 ZINC_PRIVATE_INCLUDE_DIRS )
#SET( ZINC_PRIVATE_INCLUDE_DIRS "${ZINC_PRIVATE_INCLUDE_DIRS}/.." )
#SET( ZINC_PRIVATE_INCLUDE_DIRS /home/alan/cmiss_setup/opencmiss/src/zinc/core/source )

#set(ZINC_PRIVATE_INCLUDE_DIRS "" CACHE STRING "Location of private Zinc include directory.")
LIST( GET ZINC_INCLUDE_DIRS 0 ZINC_PRIVATE_INTERNAL_DIRS )
set(ZINC_PRIVATE_INCLUDE_DIRS "${ZINC_PRIVATE_INTERNAL_DIRS}" CACHE STRING "Location of private Zinc include directory.")

#INCLUDE_DIRECTORIES( ${CMAKE_CURRENT_BINARY_DIR}/source ${CMAKE_CURRENT_SOURCE_DIR}/source
#	${ZINC_INCLUDE_DIRS} ${ZINC_PRIVATE_INCLUDE_DIRS}
#	${wxWidgets_INCLUDE_DIRS} ${FIELDML_INCLUDE_DIRS}
#	${ITK_INCLUDE_DIRS} ${CMISS_PERL_INTERPRETER_INCLUDE_DIRS} )


FOREACH( DEF ${EXTRA_COMPILER_DEFINITIONS} ${DEPENDENT_DEFINITIONS} )
	ADD_DEFINITIONS( -D${DEF} )
ENDFOREACH( DEF ${EXTRA_COMPILER_DEFINITIONS} ${DEPENDENT_DEFINITIONS} )

SET( CMGUI_TARGET cmgui )
ADD_EXECUTABLE( ${CMGUI_TARGET} WIN32 MACOSX_BUNDLE ${APP_SRCS} ${APP_HDRS} ${CMGUI_CONFIGURE_HDR} ${CMGUI_VERSION_HDR} ${wxWidgets_GENERATED_HDRS} ${OSX_ICON} )


# We want the version header to be configured at compile time and not just configure time.
set( CMGUI_VERSION_HDR ${CMAKE_CURRENT_BINARY_DIR}/source/configure/version.h )
add_custom_target(generate_version_hdr
  BYPRODUCTS ${CMGUI_VERSION_HDR}
  COMMENT "Generating the version header."
  COMMAND ${CMAKE_COMMAND}
          -DSOURCE_DIR=${CMAKE_CURRENT_SOURCE_DIR} -DVERSION_HDR=${CMGUI_VERSION_HDR}
          -DCMGUI_VERSION_STRING=${CMGUI_VERSION_STRING}
          -DCMGUI_REVISION_STRING=${CMGUI_REVISION_STRING}
          -DCMGUI_BUILD_STRING="${CMGUI_BUILD_STRING}"
          -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/ConfigureVersion.cmake)
set_source_files_properties(${CMGUI_VERSION_HDR} PROPERTIES GENERATED TRUE)
add_dependencies( ${CMGUI_TARGET} generate_version_hdr )

SET_TARGET_PROPERTIES( ${CMGUI_TARGET} PROPERTIES DEBUG_POSTFIX "d" )
IF(${CMAKE_SYSTEM_NAME} STREQUAL "Linux" AND (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX))
	SET_TARGET_PROPERTIES( ${CMGUI_TARGET} PROPERTIES
		LINK_FLAGS -Wl,-no-export-dynamic )
ENDIF()

target_include_directories(${CMGUI_TARGET} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/source ${CMAKE_CURRENT_BINARY_DIR}/source)
target_link_libraries(${CMGUI_TARGET} zinc-static wxWidgets::aui wxWidgets::xrc wxWidgets::gl)
if(USE_PERL_INTERPRETER)
	target_link_libraries(${CMGUI_TARGET} cmiss_perl_interpreter)
endif()

# On Apple platforms we need to do two extra tasks 1. Create a symbolic link for the
# application bundle to cmgui for buildbot testing and 2. Remove old Cmgui application
# bundles
IF( APPLE )
	SET( CMGUI_BUNDLE_NAME Cmgui )
	FILE( GLOB OLD_CMGUIS "${CMAKE_CURRENT_BINARY_DIR}/Cmgui*.app" )
	FOREACH( OLD_CMGUI ${OLD_CMGUIS} )
		MESSAGE( STATUS "Removing old Cmgui: ${OLD_CMGUI}" )
		EXECUTE_PROCESS( COMMAND ${CMAKE_COMMAND} -E remove_directory ${OLD_CMGUI} )
	ENDFOREACH()
	ADD_CUSTOM_COMMAND(TARGET ${CMGUI_TARGET} POST_BUILD
		COMMAND ${CMAKE_COMMAND} -E remove cmgui
		COMMAND ${CMAKE_COMMAND} -E create_symlink ${CMGUI_BUNDLE_NAME}.app/Contents/MacOS/${CMGUI_BUNDLE_NAME} cmgui
		COMMENT "Creating symlink to cmgui for Buildbot testing.")
ENDIF()

SET( CPACK_PACKAGE_NAME "Cmgui" )
SET( CPACK_GENERATOR "TGZ" )
SET( CPACK_PACKAGE_VERSION "${CMGUI_VERSION}" )
SET( CPACK_PACKAGE_VERSION_MAJOR "${CMGUI_MAJOR_VERSION}" )
SET( CPACK_PACKAGE_VERSION_MINOR "${CMGUI_MINOR_VERSION}" )
SET( CPACK_PACKAGE_VERSION_PATCH "${CMGUI_PATCH_VERSION}" )
IF( WIN32 )
	MESSAGE( STATUS "Please implement NSIS installer for me." )
	SET( CPACK_GENERATOR "ZIP;NSIS" )
ELSEIF( APPLE )
	SET( CPACK_SET_DESTDIR ON )
	LIST( APPEND CPACK_GENERATOR "PackageMaker" )
	SET( CPACK_SYSTEM_NAME "OSX" )
	SET( CPACK_RESOURCE_FILE_WELCOME ${CMAKE_CURRENT_SOURCE_DIR}/cmake/MacInstallerWelcome.txt )
	SET_TARGET_PROPERTIES( ${CMGUI_TARGET} PROPERTIES
		OUTPUT_NAME ${CMGUI_BUNDLE_NAME}
		MACOSX_BUNDLE_INFO_STRING "Cmgui 3D finite element visualisation application."
		MACOSX_BUNDLE_ICON_FILE "cmiss_torso.icns"
		MACOSX_BUNDLE_GUI_IDENTIFIER "Cmgui"
		MACOSX_BUNDLE_LONG_VERSION_STRING "${CMGUI_VERSION}${CMGUI_DEVELOPER_VERSION}"
		MACOSX_BUNDLE_BUNDLE_NAME "${CMGUI_BUNDLE_NAME}"
		MACOSX_BUNDLE_SHORT_VERSION_STRING "${CMGUI_VERSION}${CMGUI_DEVELOPER_VERSION}"
		MACOSX_BUNDLE_BUNDLE_VERSION "1.0.0"
		MACOSX_BUNDLE_COPYRIGHT "The University of Auckland, 2013" )
	SET( CMGUI_BUNDLE_LOCATION "/Applications" )
	SET( CMAKE_INSTALL_PREFIX "/Applications/${CMGUI_BUNDLE_NAME}.app/Contents" )
	SET( CMGUI_BUNDLE_DESTINATION BUNDLE DESTINATION ${CMGUI_BUNDLE_LOCATION} )
ELSEIF( UNIX )
	SET( CPACK_SET_DESTDIR ON )
	STRING( FIND "${CMGUI_SYSTEM_NAME}" "Ubuntu" INDEX )
	IF( INDEX EQUAL 0 )
		SET( CPACK_DEBIAN_PACKAGE_MAINTAINER "Hugh Sorby" ) #required
		LIST( APPEND CPACK_GENERATOR "DEB" )
	ENDIF()
ENDIF()

INSTALL( TARGETS ${CMGUI_TARGET}
	RUNTIME DESTINATION bin
	${CMGUI_BUNDLE_DESTINATION})

SET( CMGUI_ARCHITECTURE ${CMAKE_SYSTEM_PROCESSOR} )
IF( WIN32 )
	STRING( TOLOWER ${CMAKE_SYSTEM_PROCESSOR} CMGUI_ARCHITECTURE )
ENDIF()

SET( CPACK_PACKAGE_VENDOR "opencmiss" )
SET( CPACK_PACKAGE_RELOCATABLE FALSE )

SET( CPACK_RESOURCE_FILE_LICENSE ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.txt )
SET( CPACK_RESOURCE_FILE_README ${CMAKE_CURRENT_SOURCE_DIR}/README.rst )

SET( CPACK_PACKAGE_VERSION_MAJOR ${CMGUI_MAJOR_VERSION} )
SET( CPACK_PACKAGE_FILE_NAME "cmgui-${CMGUI_VERSION}${CMGUI_DEVELOPER_VERSION}-${CMGUI_ARCHITECTURE}-${CMGUI_SYSTEM_NAME}" )
SET( CPACK_OUTPUT_FILE_PREFIX "package" )

INCLUDE( CPack )

